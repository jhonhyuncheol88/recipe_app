Android 전용 Flutter 구독 앱을 위한 프로덕션급 청사진: Firebase와 BLoC 아키텍처 활용섹션 1: 기초 아키텍처: BLoC와 리포지토리 패턴을 활용한 앱 구조 설계이 섹션에서는 애플리케이션의 아키텍처 기반을 구축합니다. BLoC(Business Logic Component) 패턴과 리포지토리 패턴(Repository Pattern)을 결합하여, 관심사 분리(Separation of Concerns)라는 Model-View-Controller(MVC) 패러다임의 핵심 원칙을 현대적이고 견고하게 해석하는 방법을 설명합니다.1.1 현대 Flutter 앱을 위한 MVC 재해석전통적인 MVC 아키텍처는 현대 선언형 UI 프레임워크인 Flutter에 직접 적용하기에는 모호한 측면이 있습니다. 그러나 그 핵심 철학인 관심사 분리는 여전히 유효하며, BLoC와 리포지토리 패턴을 통해 더욱 정교하게 구현할 수 있습니다.모델 (Model): 애플리케이션의 핵심 데이터 구조를 나타내는 데이터 모델입니다. 예를 들어, UserModel이나 SubscriptionModel과 같은 클래스가 여기에 해당하며, 애플리케이션의 데이터 엔티티를 정의합니다.1뷰 (View): UI 계층을 구성하는 Flutter 위젯들입니다. 이들은 상태 변화에 반응하여 리빌드되며, 비즈니스 로직을 거의 또는 전혀 포함하지 않아야 합니다.4컨트롤러 (Controller): 이 역할은 효과적으로 두 부분으로 나뉩니다. BLoC는 상태 관리자(State Manager)로서 뷰로부터 이벤트를 수신하고 새로운 상태를 뷰로 전달하는 역할을 합니다. 반면, 리포지토리는 데이터 컨트롤러(Data Controller)로서 BLoC와 다양한 데이터 소스(Firebase 인증, Firestore, Google Play Billing API 등) 간의 중재자 역할을 수행합니다.6사용자가 요청한 "MVC 디자인 패턴"은 고전적인 구현 방식보다 BLoC와 리포지토리 패턴의 조합으로 더 우수하게 실현될 수 있습니다. 이 조합은 고전적 MVC의 목표를 달성할 뿐만 아니라, Flutter와 같은 반응형 프레임워크에 최적화된 테스트 가능하고 확장 가능한 아키텍처를 제공합니다. 전통적인 MVC에서 발생할 수 있는 복잡한 양방향 통신과 달리, 이 패턴은 단방향 데이터 흐름(Unidirectional Data Flow)을 강제하여 데이터 흐름을 예측 가능하게 만들고 디버깅을 용이하게 합니다. BLoC는 컨트롤러의 역할을 반응형 스트림 기반으로 완벽하게 수행하며 9, 리포지토리 패턴은 데이터 소스를 추상화하여 BLoC가 Firebase와 통신하는지, 아니면 모의(mock) 데이터베이스와 통신하는지 알 필요가 없게 만듭니다.7 결과적으로, 이 아키텍처는 관심사 분리를 극대화하여 더 견고하고 유지보수하기 쉬운 시스템을 구축하게 합니다.1.2 BLoC 패턴: 상태 관리의 심장BLoC 패턴은 애플리케이션 상태 관리의 핵심입니다. 그 구성 요소는 다음과 같습니다.이벤트 (Events): 사용자 상호작용이나 시스템 트리거와 같은 입력을 나타냅니다.상태 (States): UI의 특정 시점의 불변(immutable) 스냅샷입니다.블록 (Bloc): 이벤트를 상태로 변환하는 비즈니스 로직을 포함합니다.9이 애플리케이션에서는 두 개의 주요 BLoC를 정의할 것입니다: 사용자 인증 상태를 관리하는 AuthBloc과 구독 상품 조회, 구매, 상태 관리를 담당하는 SubscriptionBloc입니다.1.3 리포지토리 패턴: 데이터 소스 추상화리포지토리 패턴의 역할은 BLoC에게 깔끔한 데이터 접근 API를 제공하는 것입니다. 이를 통해 데이터가 Firebase에서 오는지, 로컬 캐시에서 오는지, 혹은 다른 API에서 오는지를 추상화하여 BLoC가 데이터 소스의 구체적인 구현에 대해 알 필요가 없게 만듭니다.6AuthRepository, UserRepository, SubscriptionRepository와 같은 추상 리포지토리 클래스를 정의하고, BLoC가 이 추상 클래스에 의존하도록 설계할 것입니다. 이는 의존성 역전 원칙(Dependency Inversion Principle)을 준수하며, 애플리케이션의 테스트 용이성과 모듈성을 크게 향상시킵니다.31.4 제안된 프로젝트 구조확장성과 유지보수성을 높이기 위해, 클린 아키텍처(Clean Architecture) 원칙에 따라 기능(auth, subscription, profile)과 계층(presentation, domain, data)을 분리한 상세한 디렉터리 구조를 설계합니다.2lib/
├── core/
│   └──... (공통 유틸리티, 상수 등)
├── data/
│   ├── models/
│   │   └── user_model.dart
│   ├── repositories/
│   │   ├── auth_repository_impl.dart
│   │   ├── subscription_repository_impl.dart
│   │   └── user_repository_impl.dart
│   └── services/
│       └──... (Firebase, Google Play 등 외부 서비스 래퍼)
├── domain/
│   ├── entities/
│   │   └── user.dart
│   ├── repositories/
│   │   ├── auth_repository.dart (추상 클래스)
│   │   ├── subscription_repository.dart (추상 클래스)
│   │   └── user_repository.dart (추상 클래스)
│   └── usecases/
│       └──... (복잡한 비즈니스 로직)
├── presentation/
│   ├── auth/
│   │   ├── bloc/
│   │   │   ├── auth_bloc.dart
│   │   │   ├── auth_event.dart
│   │   │   └── auth_state.dart
│   │   └── view/
│   │       └── login_screen.dart
│   ├── subscription/
│   │   ├── bloc/
│   │   │   ├── subscription_bloc.dart
│   │   │   ├── subscription_event.dart
│   │   │   └── subscription_state.dart
│   │   └── view/
│   │       └── paywall_screen.dart
│   └── home/
│       └── view/
│           └── home_screen.dart
└── main.dart
섹션 2: 프로젝트 초기화 및 Android용 Firebase 연동이 섹션에서는 Flutter 프로젝트를 설정하고 Firebase와 완벽하게 연동하는 과정을 단계별로 상세히 안내합니다. 이 과정은 잠재적인 오류가 발생하기 쉬운 부분이므로 세심한 주의가 필요합니다.2.1 FlutterFire CLI를 활용한 견고한 설정수동 설정으로 인한 일반적인 구성 오류를 방지하기 위해, 최신 접근 방식인 FlutterFire CLI를 사용하는 것을 강력히 권장합니다.14Firebase CLI 및 FlutterFire CLI 설치: 먼저, Firebase와 FlutterFire의 명령줄 인터페이스(CLI)를 설치해야 합니다. 이는 Firebase 프로젝트와의 상호작용을 자동화하는 데 필수적입니다.14Bash# Firebase CLI 설치 (Node.js 필요)
npm install -g firebase-tools
firebase login

# FlutterFire CLI 활성화
dart pub global activate flutterfire_cli
프로젝트 구성: 프로젝트의 루트 디렉터리에서 flutterfire configure 명령을 실행합니다. 이 명령은 Firebase 프로젝트를 선택하고, Android 플랫폼을 위한 firebase_options.dart 파일을 자동으로 생성하며, 네이티브 Android 프로젝트 설정을 수정합니다.152.2 SHA-1 및 SHA-256 지문의 핵심적 역할SHA 키는 암호화된 서명 역할을 하여, Google 로그인과 같은 Firebase 서비스가 요청이 인증된 Android 앱에서 온 것인지 확인하는 데 사용됩니다. 이 키가 없거나 잘못되면 인증이 조용히 실패할 수 있습니다.19 디버그 및 릴리스 빌드 모두에 대해 정확한 키를 생성하고 등록하는 것이 매우 중요합니다.디버그 SHA 키 생성: Android Studio 내에서 Gradle signingReport 작업을 실행하여 디버그용 SHA-1 및 SHA-256 키를 쉽게 생성할 수 있습니다.22Android Studio의 오른쪽 패널에서 Gradle 탭을 엽니다.[project_name] -> Tasks -> android -> signingReport를 더블 클릭합니다.Run 탭의 콘솔 출력에서 SHA-1 및 SHA-256 값을 복사합니다.릴리스 SHA 키 생성: 프로덕션 빌드를 위해서는 릴리스 키 저장소(keystore)를 생성하고 keytool 유틸리티를 사용하여 지문을 추출해야 합니다. 이는 앱을 Google Play에 게시하기 위한 필수 단계입니다.26Bashkeytool -list -v -keystore <path-to-your-release-keystore>.jks -alias <your-alias>
Firebase 콘솔에 지문 추가: 생성된 SHA-1 및 SHA-256 지문을 Firebase 콘솔의 프로젝트 설정 > 내 앱 > Android 앱 섹션에 있는 SHA 인증서 지문 필드에 추가합니다.19FlutterFire CLI는 Firebase 설정을 크게 간소화했지만, 이것이 수동 구성 단계를 완전히 무시해도 된다는 의미는 아닙니다. 오히려, CLI가 자동화하는 작업(Gradle 파일 수정, google-services.json 배치 등)에 대한 깊은 이해는 이제 필수적인 디버깅 기술이 되었습니다. 예를 들어, Google 로그인이 실패하는 일반적인 원인은 SHA-1 키가 누락되거나 잘못된 경우입니다.20 CLI는 프로젝트를 추가하지만, 개발자는 여전히 수동으로 SHA 키를 생성하고 Firebase 콘솔에 추가해야 합니다. 또한, 복잡한 프로젝트에서는 build.gradle의 패키지 이름과 Firebase 콘솔, google-services.json 파일 간의 불일치가 발생할 수 있습니다.28 따라서 통합 실패 시, 개발자는 CLI가 수행했어야 하는 작업을 감사할 수 있어야 합니다. 즉, 생성된 구성 파일들을 수동 설정 문서와 비교하여 불일치를 진단하는 능력이 필요합니다.29 과거의 구현 지식은 이제 필수적인 디버깅 및 검증 도구로 전환되었습니다.2.3 Android 네이티브 파일의 정확한 구성FlutterFire CLI가 대부분의 작업을 처리하지만, 다음 사항을 확인하는 것이 좋습니다.google-services.json 파일: 이 파일이 android/app/ 디렉터리에 올바르게 위치해 있는지 확인합니다.27 이 파일에는 Firebase 프로젝트와 앱을 연결하는 중요한 구성 정보가 포함되어 있습니다.28Gradle 파일: 프로젝트 수준 android/build.gradle 파일에 Google Services 클래스패스가 추가되었는지, 그리고 앱 수준 android/app/build.gradle 파일에 Google Services 플러그인이 적용되었는지 확인합니다.29섹션 3: AuthBloc을 이용한 Google 로그인 구현이 장에서는 Firebase 인증과 BLoC 패턴을 사용하여 완전한 사용자 인증 생명주기를 구현하는 방법을 상세히 설명합니다.3.1 Firebase 인증 설정가장 먼저 Firebase 콘솔의 Authentication > Sign-in method 탭으로 이동하여 Google 로그인 제공업체를 활성화해야 합니다. 이는 Google 로그인을 사용하기 위한 필수적인 사전 단계입니다.193.2 인증 리포지토리 구축AuthRepository 클래스는 Firebase Auth 및 google_sign_in 패키지와의 직접적인 상호작용을 캡슐화합니다.6 이 클래스는 Future<User?> signInWithGoogle() 및 Future<void> signOut()과 같은 메서드를 노출합니다. signInWithGoogle 메서드의 구현은 Google 로그인 흐름을 트리거하고, 인증 정보를 얻어 FirebaseAuth.instance.signInWithCredential()에 전달하는 로직을 포함합니다.203.3 인증 이벤트 및 상태 정의BLoC의 핵심은 명확하게 정의된 이벤트와 상태입니다.AuthEvents:AppStarted: 앱 시작 시 초기 인증 상태를 확인합니다.GoogleSignInRequested: 사용자가 Google 로그인을 요청할 때 발생합니다.SignOutRequested: 사용자가 로그아웃을 요청할 때 발생합니다.10AuthStates:AuthInitial: 초기 상태입니다.AuthLoading: 인증 과정이 진행 중임을 나타냅니다.Authenticated: 인증에 성공했으며, Firebase User 객체를 포함합니다.Unauthenticated: 인증되지 않은 상태입니다.AuthFailure: 인증 과정에서 오류가 발생했으며, 오류 메시지를 포함합니다.1상태 클래스들은 Equatable을 상속받아 불필요한 UI 리빌드를 방지하는 것이 중요합니다.3.4 AuthBloc 구현AuthBloc은 AuthRepository를 의존성으로 주입받아 이벤트에 따라 상태를 변경하는 로직을 처리합니다.GoogleSignInRequested 이벤트가 발생하면, emit(AuthLoading())을 통해 로딩 상태를 알리고, 리포지토리의 signInWithGoogle() 메서드를 호출합니다. 성공 시 emit(Authenticated(user))를, 실패 시 emit(AuthFailure(error))를 발생시킵니다.10단순히 로그인/로그아웃 액션을 관리하는 것을 넘어, 견고한 아키텍처는 FirebaseAuth.instance.authStateChanges() 스트림을 인증 상태의 유일한 진실 공급원(Single Source of Truth)으로 다루어야 합니다.33AuthBloc은 이 스트림의 구독자가 되어야 합니다. 예를 들어, 사용자의 세션이 서버 측에서 무효화될 경우(다른 기기에서 비밀번호 변경 등), 앱은 signOut()이 로컬에서 호출되지 않았더라도 이 상태 변화를 감지해야 합니다. AuthBloc이 생성될 때 authStateChanges() 스트림을 구독하면, 이 스트림은 현재 사용자 상태를 즉시 방출하고 이후 상태가 변경될 때마다 새로운 이벤트를 전달합니다. 이 스트림이 User 객체를 방출하면 BLoC는 Authenticated 상태를, null을 방출하면 Unauthenticated 상태를 내보냅니다. 이로써 앱의 상태가 항상 백엔드의 실제 상태와 동기화되어 시스템의 회복탄력성이 크게 향상됩니다.3.5 UI와 인증 상태 통합main.dart 파일에서 BlocProvider를 사용하여 위젯 트리의 최상단에 AuthBloc을 제공합니다.35 그 후, AuthGate나 Wrapper와 같은 루트 위젯에서 BlocBuilder 또는 BlocListener를 사용하여 AuthState에 따라 적절한 화면으로 이동시킵니다. 예를 들어, 상태가 Authenticated이면 HomeScreen을, Unauthenticated이면 LoginScreen을 보여주는 반응형 내비게이션 흐름을 만듭니다.363.6 최초 로그인 시 Firestore에 사용자 데이터 저장signInWithCredential 호출이 성공적으로 완료된 후, userCredential.additionalUserInfo!.isNewUser 속성을 확인하여 새로운 사용자인지 판별합니다. 만약 새로운 사용자라면, Firestore의 users 컬렉션에 해당 사용자의 문서를 생성합니다.39 이 과정은 모든 인증된 사용자가 자신의 프로필 문서를 갖도록 보장합니다.섹션 4: 구독 관리를 위한 확장 가능한 Firestore 사용자 모델 설계이 섹션에서는 사용자 프로필과 동적인 구독 상태를 관리하기 위해 Cloud Firestore에 유연하고 확장 가능한 데이터 모델을 설계하는 방법을 상세히 설명합니다.4.1 Firestore 데이터 모델링 원칙Firestore는 데이터를 문서(documents)에 저장하고, 이 문서들은 컬렉션(collections)으로 구성되는 NoSQL 데이터베이스입니다.42 구독 데이터와 같이 함께 조회될 가능성이 높은 정보는 중첩된 맵(map) 형태로 사용자 문서 내에 저장하는 것이 단일 문서 읽기만으로 모든 정보를 가져올 수 있어 효율적입니다.454.2 users 컬렉션 스키마최상위 수준에 users 컬렉션을 정의합니다.각 문서의 ID는 Firebase 인증에서 제공하는 사용자의 uid로 설정합니다. 이는 인증된 사용자와 그들의 데이터를 직접적이고 안전하게 연결하는 방법입니다.39문서에는 Google 로그인 제공업체로부터 받은 기본 프로필 정보(예: displayName, email, photoURL)를 저장합니다.334.3 subscription 필드: 상태 관리의 핵심각 사용자 문서에 Map 타입의 subscription 필드를 추가합니다. 이 필드는 모든 구독 관련 정보의 중앙 저장소 역할을 합니다.표: Firestore 사용자 문서 스키마필드 이름데이터 타입설명uidStringFirebase Auth의 고유 사용자 ID (기본 키)emailString사용자의 이메일 주소displayNameString사용자의 표시 이름photoURLString사용자 프로필 사진 URLcreatedAtTimestamp사용자의 최초 로그인 타임스탬프subscriptionMap모든 구독 관련 데이터를 포함하는 맵↳ statusString현재 구독 상태 (예: 'active', 'expired', 'cancelled', 'in_grace_period')↳ productIdString현재 구독 중인 Google Play 상품 ID (예: 'monthly_premium', 'yearly_premium')↳ expiresDateTimestamp구독이 만료될 정확한 날짜와 시간↳ purchaseDateTimestamp가장 최근 구매 또는 갱신 날짜↳ sourceString구매 출처 (예: 'google_play')4.4 데이터 모델의 정당성효율성: 구독 데이터를 사용자 문서 내의 맵에 저장하면, 단일 문서 읽기 작업으로 사용자의 프로필과 구독 상태를 모두 가져올 수 있어 비용 효율적이고 빠릅니다.47보안: Firestore 보안 규칙을 사용하여 인증된 사용자만이 자신의 데이터를 읽을 수 있도록 접근을 제어할 수 있습니다 (allow read: if request.auth.uid == resource.data.uid;).확장성: 이 모델은 Google Play 스토어에서 직접 발생하는 갱신이나 취소와 같은 앱 외부의 구독 이벤트가 발생했을 때, Cloud Function과 같은 백엔드에서 쉽게 데이터를 업데이트할 수 있게 해줍니다.48프리미엄 상태를 관리하기 위해 Firebase 커스텀 클레임(Custom Claims)을 사용하는 방법도 고려할 수 있지만 49, 시간 기반의 외부 관리형 구독 상태에는 적합하지 않습니다. 커스텀 클레임은 사용자의 ID 토큰이 갱신될 때(보통 1시간 주기) 또는 재로그인 시에만 새로고침됩니다.34 만약 사용자가 Play 스토어에서 구독을 취소하면, 커스텀 클레임은 최대 1시간 동안 유효하게 남아 무단 액세스를 허용할 수 있습니다. 반면, Firestore 문서 접근 방식은 이 문제를 해결합니다. 백엔드 웹훅이나 예약된 함수가 Play 스토어 알림을 수신하여 Firestore의 subscription 필드를 실시간으로 업데이트할 수 있습니다. 클라이언트 앱은 자신의 사용자 문서에 대한 실시간 리스너(snapshots())를 설정하여 44, 백엔드가 구독 상태를 업데이트하는 즉시 알림을 받고 UI를 즉각적으로 변경하여 접근 권한을 철회할 수 있습니다. 이는 Firestore 문서를 구독 상태에 대한 유일하고 신뢰할 수 있는 실시간 정보 소스로 만듭니다.섹션 5: Google Play Console에서 구독 상품 구성하기이 섹션에서는 Google Play Console에서 월간 및 연간 구독 상품을 설정하는 과정을 스크린샷과 함께 실질적으로 안내하여 현대적인 구독 모델을 명확히 설명합니다.5.1 초기 앱 및 결제 프로필 설정Play Console에서 앱 항목을 생성하고 초기 설정을 완료합니다.51상품을 판매하기 위한 전제 조건인 결제 프로필을 설정합니다.515.2 구독 계층 구조 이해: 상품, 기본 요금제, 혜택구독 (Subscription): 개념적 상품입니다 (예: "프리미엄 멤버십").53기본 요금제 (Base Plan): 청구 기간(월간, 연간), 가격, 갱신 유형(자동 갱신) 등 핵심 청구 조건을 정의합니다. 월간 및 연간 두 가지 기본 요금제를 생성할 것입니다.53혜택 (Offer): 특정 자격 요건을 갖춘 사용자에게 제공되는 특별 가격입니다 (예: 신규 고객을 위한 7일 무료 체험). 소개 혜택을 만드는 방법을 시연할 것입니다.55이 계층적 구조는 Google Play 결제의 비교적 새로운 모델이며, 유연한 수익화 전략을 구현하기 위해 각 구성 요소를 명확히 구분하는 것이 필수적입니다.5.3 단계별 상품 생성Play Console에서 수익 창출 > 상품 > 구독으로 이동합니다.53고유한 상품 ID(예: premium_access)를 사용하여 "프리미엄" 주 구독 상품을 생성합니다.월간 기본 요금제를 추가합니다. 고유한 기본 요금제 ID(예: premium_monthly)를 설정하고, 청구 기간을 1개월로, 가격을 설정합니다.57연간 기본 요금제를 추가합니다. 고유한 기본 요금제 ID(예: premium_yearly)를 설정하고, 청구 기간을 1년으로, 일반적으로 할인된 가격을 설정합니다.57생성된 기본 요금제들을 '활성화'하여 구매 가능하도록 만듭니다.555.4 테스트 설정테스트는 실제 돈을 청구하지 않고 전체 구매 흐름을 검증하는 데 매우 중요합니다.Play Console의 설정 > 라이선스 테스트로 이동합니다.52라이선스 테스터로 사용할 Google 계정 이메일 주소를 추가합니다. 이 계정들은 테스트 결제 수단을 사용하여 실제 청구 없이 구매를 완료할 수 있습니다.59상품이 테스터에게 표시되려면 앱이 최소한 내부 테스트 트랙에 게시되어야 한다는 점을 유의해야 합니다.51섹션 6: SubscriptionBloc을 이용한 인앱 결제 연동이 섹션에서는 공식 in_app_purchase 패키지와 전용 SubscriptionBloc을 사용하여 클라이언트 측 인앱 결제 흐름을 구현하는 방법을 상세히 설명합니다.6.1 in_app_purchase 패키지 구성pubspec.yaml 파일에 in_app_purchase 의존성을 추가합니다.59앱의 루트 위젯에서 InAppPurchase.instance.purchaseStream에 대한 영구적인 리스너를 초기화합니다. 이는 앱이 백그라운드에 있거나 종료된 상태에서 완료된 구매를 처리하는 데 매우 중요합니다.63purchaseStream은 단순히 활성 구매 흐름에 대한 콜백이 아닙니다. 이것은 오프라인이나 다른 컨텍스트에서 발생한 구매를 포함하여 모든 구매 업데이트를 전달하는 상태 저장 스트림입니다. 앱 실행 시 이 리스너를 초기화하지 않는 것은 "잃어버린" 구매의 주된 원인이 됩니다. 예를 들어, 사용자가 오프라인 상태에서 결제를 완료하고 앱을 닫았다가 나중에 다시 열면, Play 스토어는 거래를 완료합니다. 만약 리스너가 페이월 화면에만 있다면 앱은 이 PurchaseStatus.purchased 업데이트를 받지 못할 것입니다. 올바른 아키텍처는 앱의 루트 위젯(main.dart의 MyApp 위젯 등)의 initState에서 StreamSubscription을 설정하는 것입니다.66 이렇게 하면 앱이 시작되자마자 이전 세션의 보류 중인 구매 업데이트를 수신할 준비가 되어, 사용자에게 원활한 경험을 제공할 수 있습니다.6.2 구독 리포지토리 구축SubscriptionRepository는 in_app_purchase 플러그인과의 모든 상호작용을 캡슐화합니다. Future<List<ProductDetails>> loadProducts(), Future<void> purchaseProduct(ProductDetails product)와 같은 메서드를 포함하며, BLoC가 수신할 purchaseStream을 노출합니다.6.3 구독 이벤트 및 상태 정의SubscriptionEvents: LoadProductsRequested, PurchaseRequested(ProductDetails product), PurchaseUpdated(PurchaseDetails purchaseDetails).SubscriptionStates: SubscriptionInitial, ProductsLoading, ProductsLoaded(List<ProductDetails> products), PurchaseInProgress, PurchaseSuccessful(PurchaseDetails purchase), PurchaseFailed(IAPError error), PurchaseRestored.6.4 SubscriptionBloc 구현SubscriptionBloc은 SubscriptionRepository를 의존성으로 가집니다.LoadProductsRequested 이벤트 시, 리포지토리를 호출하여 Play Console에서 정의한 상품 ID(예: premium_monthly, premium_yearly)로 queryProductDetails를 실행하고, ProductsLoaded 또는 PurchaseFailed 상태를 내보냅니다.59PurchaseRequested 이벤트 시, InAppPurchase.instance.buyNonConsumable()을 호출하여 구매 흐름을 시작하고 PurchaseInProgress 상태를 내보냅니다 (구독은 비소모성 상품으로 취급됨).63BLoC는 리포지토리의 purchaseStream에 대한 StreamSubscription을 가집니다. 새로운 PurchaseDetails 객체가 도착하면, PurchaseUpdated 이벤트를 자신에게 추가하고, purchase.status에 따라 PurchaseSuccessful 또는 PurchaseFailed 상태를 내보냅니다.656.5 페이월 UI 구축UI는 SubscriptionBloc을 수신하는 BlocBuilder를 사용합니다.상태가 ProductsLoading일 때는 로딩 인디케이터를 표시합니다.상태가 ProductsLoaded일 때는 ProductDetails 목록에서 동적으로 구독 옵션(예: "월간 요금제", "연간 요금제" 버튼)을 구축합니다.각 버튼의 onPressed 콜백은 해당 ProductDetails 객체와 함께 PurchaseRequested 이벤트를 SubscriptionBloc에 추가합니다.BlocListener는 전체 UI를 다시 빌드하지 않고 성공 또는 실패 상태에 대한 스낵바나 다이얼로그를 표시하는 데 사용됩니다.65섹션 7: Cloud Functions를 통한 서버 측 검증으로 거래 보안 강화이 섹션에서는 인앱 결제의 가장 중요한 보안 측면인 서버 측 검증을 다룹니다. 이것이 왜 필수적인지 설명하고 Firebase Cloud Functions를 사용한 완전한 구현을 제공합니다.7.1 클라이언트 측 검증의 내재된 불안정성루팅된 기기나 수정된 APK와 같은 손상된 클라이언트는 성공적인 구매 콜백을 위조하여 프리미엄 기능에 대한 무단 액세스를 얻을 수 있습니다. 클라이언트의 보고서에만 의존하는 것은 검증되지 않은 입력을 신뢰하는 것과 같으므로 매우 위험합니다.527.2 Google Play Developer API 설정Google Cloud Console로 이동하여 서비스 계정(Service Account)을 생성합니다.73Google Play Console에서 해당 서비스 계정에 "재무" 또는 동등한 권한을 부여하여 구매 데이터에 접근할 수 있도록 합니다.73Cloud Function을 인증하는 데 사용할 서비스 계정의 JSON 키 파일을 다운로드합니다.7.3 verifyPurchase Cloud Function 구현Node.js/TypeScript로 작성된 HTTP 호출 가능 Cloud Function을 생성합니다.이 함수는 Flutter 앱으로부터 packageName, productId, purchaseToken을 안전하게 수신합니다. purchaseToken은 PurchaseDetails 객체의 verificationData에 포함되어 있습니다.63공식 Google API 클라이언트 라이브러리(googleapis)를 사용하여 Google Play Developer API의 purchases.subscriptions.get 엔드포인트를 호출합니다.75Google 서버로부터의 응답을 확인합니다. 유효한 purchaseState(예: 1은 "결제 완료")를 포함한 성공적인 응답은 구매가 합법적임을 확인합니다.78함수는 Flutter 앱에 명확한 성공 또는 실패 상태를 반환합니다.검증 Cloud Function의 역할은 단순한 "예/아니오" 확인을 넘어섭니다. 이 함수는 거래에 대한 유일하고 신뢰할 수 있는 처리 장치로 취급되어야 합니다. 즉, 구매를 검증하고 데이터베이스에서 사용자의 공식 구독 상태를 업데이트할 책임이 있는 유일한 구성 요소여야 합니다. 클라이언트 앱은 PurchaseDetails 객체를 받지만, 이는 구매의 주장일 뿐 증거는 아닙니다. 클라이언트는 이 주장의 purchaseToken을 Cloud Function으로 보냅니다.73 Cloud Function은 진실의 원천인 Google의 결제 서버와 직접 통신합니다.79 Google이 구매가 유효하다고 확인하면, Cloud Function은 단순히 "성공"을 반환하는 것이 아니라 Firebase Admin SDK를 사용하여 사용자의 Firestore 문서에 업데이트된 구독 상태(status: 'active', expiresDate 등)를 직접 기록해야 합니다. 그러면 클라이언트의 역할은 함수로부터 성공 응답을 받은 후 InAppPurchase.instance.completePurchase()를 호출하여 거래를 확인하는 것으로 단순화됩니다. 이 아키텍처는 클라이언트가 구매를 성공적으로 검증했지만 네트워크 문제로 Firestore 업데이트에 실패하는 시나리오를 방지하여 더 안전하고 견고한 시스템을 만듭니다.7.4 Firebase App Check으로 보안 강화Firebase App Check을 통합하여 verifyPurchase Cloud Function이 인증된 앱 인스턴스에서만 호출될 수 있도록 보장함으로써 남용 및 재전송 공격으로부터 보호합니다.81섹션 8: 구매 완료 및 사용자 상태 동기화이 섹션에서는 클라이언트 측 흐름, 서버 측 검증, 데이터베이스 업데이트를 하나의 원활하고 안전한 거래 프로세스로 통합합니다.8.1 완전하고 안전한 구매 흐름 (단계별)UI: 사용자가 "구독하기" 버튼을 탭합니다. SubscriptionBloc이 PurchaseRequested 이벤트를 수신합니다.클라이언트: in_app_purchase 플러그인이 Google Play 구매 시트를 표시합니다.클라이언트: 사용자가 구매를 완료합니다. purchaseStream은 status: PurchaseStatus.purchased와 pendingCompletePurchase: true를 가진 PurchaseDetails 객체를 방출합니다.클라이언트: SubscriptionBloc의 리스너가 이 PurchaseDetails 객체를 수신하고 "검증 중..." 상태를 내보냅니다.클라이언트 -> 서버: 앱은 verificationData.serverVerificationData에서 purchaseToken을 추출하여 verifyPurchase Cloud Function을 호출합니다.63서버: Cloud Function이 Google Play Developer API로 토큰을 검증합니다. 성공 시, 사용자의 Firestore 문서를 새로운 구독 정보로 업데이트하고 클라이언트에 성공 메시지를 반환합니다.클라이언트: Cloud Function으로부터 성공 응답을 받으면, 앱은 InAppPurchase.instance.completePurchase(purchaseDetails)를 호출합니다.클라이언트: SubscriptionBloc이 최종 PurchaseSuccessful 상태를 내보내고, UI는 프리미엄 콘텐츠를 표시하도록 업데이트됩니다.8.2 completePurchase()의 중요성completePurchase() 호출은 Google Play 스토어에 거래를 확인(acknowledge)하는 역할을 합니다. 이 호출이 3일 이내에 이루어지지 않으면, Google은 자동으로 사용자에게 환불하고 구매를 취소합니다.63 우리의 아키텍처는 이 호출이 성공적인 서버 측 검증 및 데이터베이스 업데이트 이후에만 이루어지도록 보장하여, 사기성 구매를 확인하거나 유효한 구매에 대한 접근 권한을 부여하지 못하는 경우를 방지합니다.8.3 구매 오류 및 실패 처리SubscriptionBloc은 purchaseStream에서 발생하는 오류(예: PurchaseStatus.error)나 Cloud Function 호출 실패 등을 포착하여 PurchaseFailed 상태를 내보냅니다. UI는 BlocListener를 통해 다양한 실패 시나리오에 대해 "구매가 취소되었습니다" 또는 "검증에 실패했습니다. 고객 지원에 문의하세요"와 같은 사용자 친화적인 오류 메시지를 표시합니다.65섹션 9: 앱 전체에서 구독 상태 관리 및 반응마지막 섹션에서는 전체 애플리케이션이 사용자의 구독 상태를 실시간으로 인지하고, 프리미엄 기능 잠금 해제와 같은 동적 UI 변경을 가능하게 하는 데 중점을 둡니다.9.1 MultiBlocProvider를 통한 전역 상태 접근main.dart에서 MultiBlocProvider로 MaterialApp을 감싸 AuthBloc과 SubscriptionBloc을 전체 위젯 트리에서 사용할 수 있도록 만듭니다.859.2 실시간 구독 리스너진정으로 반응적인 시스템의 핵심은 실시간 리스너입니다. SubscriptionBloc은 사용자가 인증되면(AuthBloc의 상태를 수신하여 알 수 있음) 현재 사용자의 Firestore 문서에 대한 실시간 스트림 리스너를 생성합니다: FirebaseFirestore.instance.collection('users').doc(user.uid).snapshots().이 문서가 변경될 때마다(인앱 구매 또는 백엔드 업데이트로 인해) 스트림이 실행됩니다. SubscriptionBloc은 문서 데이터에서 subscription 맵을 파싱하고 새로운 SubscriptionState(예: SubscriptionStatusUpdated(isSubscribed: true, expiryDate:...) )를 내보냅니다.9.3 UI 동적 제어프리미엄 기능을 표시하거나 숨겨야 하는 모든 위젯은 BlocBuilder<SubscriptionBloc, SubscriptionState>를 사용합니다. builder 함수는 현재 상태의 속성(예: state.isSubscribed)을 확인하여 위젯을 조건부로 렌더링합니다. 예를 들어, if (state.isSubscribed) { return PremiumFeatureWidget(); } else { return UpsellWidget(); }와 같이 구현할 수 있습니다.889.4 로그아웃 처리AuthBloc이 SignOutRequested 이벤트를 처리하여 사용자를 로그아웃시킬 때, SubscriptionBloc에도 신호를 보내 Firestore 리스너를 취소하고 상태를 SubscriptionInitial로 재설정해야 합니다. 이는 이전 사용자 세션의 데이터가 유출되는 것을 방지합니다. 이는 공유 리포지토리나 스트림 구독을 통한 BLoC 간 통신으로 달성할 수 있습니다.이러한 AuthBloc과 SubscriptionBloc 간의 상호작용은 단순한 두 개의 개별 BLoC를 넘어, 응집력 있고 회복탄력성 있는 애플리케이션 전체의 상태 머신을 형성합니다. SubscriptionBloc의 생명주기는 AuthBloc의 상태에 근본적으로 의존하며, 이 의존성을 올바르게 관리하면 복잡한 엣지 케이스들이 자동으로 처리됩니다. 예를 들어, 사용자가 Google Play 스토어에서 직접 구독을 취소하면, 백엔드 웹훅이 Firestore 문서를 업데이트하고, SubscriptionBloc의 리스너가 이를 감지하여 UI에서 즉시 프리미엄 기능을 잠급니다. 사용자가 로그아웃하면 AuthBloc의 상태 변화에 따라 SubscriptionBloc의 리스너가 자동으로 해제되어 데이터 유출을 방지합니다. 이처럼 상호 연결된 시스템은 개발자가 모든 가능한 시나리오에 대해 수동으로 상태 전환을 관리할 필요 없이, 반응형 스트림과 BLoC 의존성이 논리를 처리하여 강력하고 자율적으로 조절되는 시스템을 만듭니다.결론본 보고서는 Flutter, Firebase, BLoC 패턴을 사용하여 Android 플랫폼을 위한 프로덕션급 구독 기반 애플리케이션을 구축하는 포괄적인 청사진을 제시했습니다. 제안된 아키텍처는 BLoC와 리포지토리 패턴을 통해 고전적인 MVC의 원칙을 현대적으로 재해석하여, 테스트 용이성과 확장성이 뛰어난 단방향 데이터 흐름을 구현합니다.성공적인 구현의 핵심 요소는 다음과 같습니다:자동화와 수동 검증의 조화: FlutterFire CLI를 사용하여 초기 설정을 자동화하되, SHA 키 생성 및 Gradle 파일 구성과 같은 핵심적인 네이티브 설정에 대한 깊은 이해를 바탕으로 문제를 진단하고 해결하는 능력이 필수적입니다.상태의 단일 진실 공급원: FirebaseAuth.instance.authStateChanges() 스트림과 사용자의 Firestore 문서를 각각 인증 및 구독 상태의 유일한 진실 공급원으로 삼아, 앱의 상태가 외부 요인에 의해서도 항상 백엔드와 동기화되도록 보장해야 합니다.서버 측 검증의 의무화: 모든 인앱 결제는 클라이언트의 보고에 의존하지 않고, Firebase Cloud Functions를 통해 Google Play Developer API와 직접 통신하여 서버 측에서 검증되어야 합니다. 또한, 검증된 거래는 서버가 직접 Firestore 문서를 업데이트하여 데이터의 무결성을 보장해야 합니다.상호작용하는 BLoC 설계: AuthBloc과 SubscriptionBloc을 독립적으로 운영하는 것이 아니라, 인증 상태에 따라 구독 리스너의 생명주기를 관리하는 상호 의존적인 시스템으로 설계하여 앱 전체의 상태를 견고하고 예측 가능하게 만듭니다.이러한 원칙과 상세 구현 가이드를 따르면, 개발자는 안전하고, 유지보수하기 쉬우며, 사용자에게 원활한 경험을 제공하는 고품질의 구독 애플리케이션을 구축할 수 있을 것입니다.